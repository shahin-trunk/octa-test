version: '3.8'

services:
  traefik:
    image: traefik:v3.0
    command:
      - "--api=true"
      - "--api.dashboard=true"
      - "--providers.docker=true"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--certificatesresolvers.letsencrypt.acme.email=${TRAEFIK_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge=true"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./letsencrypt:/letsencrypt
    networks:
      - web
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(`${TRAEFIK_HOST}`)"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.traefik.middlewares=auth"
      - "traefik.http.middlewares.auth.basicauth.users=${TRAEFIK_BASICAUTH_USERS}"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8080/ping" ]
      interval: 10s
      timeout: 5s
      retries: 5

  postgresql:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - ./postgresql_data:/var/lib/postgresql/data
    networks:
      - internal
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres" ]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"

  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    volumes:
      - ./pgadmin_data:/var/lib/pgadmin
    networks:
      - web
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.pgadmin.rule=Host(`${PGADMIN_HOST}`)"
      - "traefik.http.routers.pgadmin.entrypoints=websecure"
      - "traefik.http.routers.pgadmin.tls.certresolver=letsencrypt"
    depends_on:
      postgresql:
        condition: service_healthy
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:80" ]
      interval: 10s
      timeout: 5s
      retries: 5

  mongo:
    image: mongo:6.0
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
    volumes:
      - ./mongo_data:/data/db
    networks:
      - internal
    healthcheck:
      test: [ "CMD", "mongo", "--eval", "db.runCommand({ping:1})" ]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"

  mongo-express:
    image: mongo-express
    environment:
      ME_CONFIG_MONGODB_URL: "mongo://root:${MONGO_ROOT_PASSWORD}@mongo:27017/"
    networks:
      - web
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.mongo-express.rule=Host(`${MONGO_EXPRESS_HOST}`)"
      - "traefik.http.routers.mongo-express.entrypoints=websecure"
      - "traefik.http.routers.mongo-express.tls.certresolver=letsencrypt"
    depends_on:
      mongo:
        condition: service_healthy
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8081" ]
      interval: 10s
      timeout: 5s
      retries: 5

  lancedb:
    build: ./lancedb
    image: lancedb/lancedb
    volumes:
      - ./lancedb_data:/data  # Adjust based on documentation
    networks:
      - web
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.lancedb.rule=Host(`${LANCEDB_HOST}`)"
      - "traefik.http.routers.lancedb.entrypoints=websecure"
      - "traefik.http.routers.lancedb.tls.certresolver=letsencrypt"
      - "traefik.http.services.lancedb.loadbalancer.server.port=8080"
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
    #   interval: 10s
    #   timeout: 5s
    #   retries: 5

  qdrant:
    image: qdrant/qdrant
    volumes:
      - ./qdrant_data:/qdrant/data  # Adjust based on documentation
    networks:
      - web
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.qdrant.rule=Host(`${QDRANT_HOST}`)"
      - "traefik.http.routers.qdrant.entrypoints=websecure"
      - "traefik.http.routers.qdrant.tls.certresolver=letsencrypt"
      - "traefik.http.services.qdrant.loadbalancer.server.port=6333"
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:6333/health"]
    #   interval: 10s
    #   timeout: 5s
    #   retries: 5

  nebula-meta:
    image: vesoft/nebula-metad
    volumes:
      - ./nebula-meta-data:/var/nebula/meta
    networks:
      - internal
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"

  nebula-graph:
    image: vesoft/nebula-graphd
    volumes:
      - ./nebula-graph-data:/var/nebula/graph
    networks:
      - internal
    depends_on:
      - nebula-meta
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"

  nebula-storage:
    image: vesoft/nebula-storaged
    volumes:
      - ./nebula-storage-data:/var/nebula/storage
    networks:
      - internal
    depends_on:
      - nebula-meta
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "10m"

#  nebula-web:
#    image: vesoft/nebula-web
#    environment:
#      - NEBULA_GRAPH_ADDR=nebula-graph:9669
#      - NEBULA_META_ADDR=nebula-meta:9559
#      - NEBULA_STORAGE_ADDR=nebula-storage:9779
#    networks:
#      - web
#      - internal
#    labels:
#      - "traefik.enable=true"
#      - "traefik.http.routers.nebula-web.rule=Host(`${NEBULA_WEB_HOST}`)"
#      - "traefik.http.routers.nebula-web.entrypoints=websecure"
#      - "traefik.http.routers.nebula-web.tls.certresolver=letsencrypt"
#    depends_on:
#      - nebula-meta
#      - nebula-graph
#      - nebula-storage
#    restart: unless-stopped
#    logging:
#      driver: "json-file"
#      options:
#        max-size: "10m"
#    healthcheck:
#      test: [ "CMD", "curl", "-f", "http://localhost:80" ]
#      interval: 10s
#      timeout: 5s
#      retries: 5

  redis:
    image: docker.io/valkey/valkey:8-alpine
    command: valkey-server --save 30 1 --loglevel warning
    restart: unless-stopped
    networks:
      - internal
    volumes:
      - ./valkey_data:/data
    cap_drop:
      - ALL
    cap_add:
      - SETGID
      - SETUID
      - DAC_OVERRIDE
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    healthcheck:
      test: [ "CMD-SHELL", "valkey-cli ping | grep PONG" ]
      interval: 10s
      timeout: 5s
      retries: 5

  searxng:
    image: docker.io/searxng/searxng:latest
    restart: unless-stopped
    networks:
      - web
      - internal
    volumes:
      - ./searxng_config:/etc/searxng:rw
    environment:
      - SEARXNG_BASE_URL=https://${SEARXNG_HOST:-localhost}/
      - UWSGI_WORKERS=${SEARXNG_UWSGI_WORKERS:-4}
      - UWSGI_THREADS=${SEARXNG_UWSGI_THREADS:-4}
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.searxng.rule=Host(`${SEARXNG_HOST}`)"
      - "traefik.http.routers.searxng.entrypoints=websecure"
      - "traefik.http.routers.searxng.tls.certresolver=letsencrypt"
      - "traefik.http.services.searxng.loadbalancer.server.port=8080"
    # cap_drop:
    #   - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID
    depends_on:
      redis:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8080" ]
      interval: 10s
      timeout: 5s
      retries: 5

networks:
  web:
    driver: bridge
  internal:
    driver: bridge
    internal: true